\section{Deadlockerkennung allgemein}
\label{section:Deadlockerkennung allgemein}
Im Gegensatz zu Singlethreaded Applikationen sind Multithreaded Anwendungen
nicht deterministisch. Dies kann zu \textit{race conditions} führen. Eine
\textit{race condition} tritt zum Beispiel dann auf, wenn zwei Threads einen
Zähler jeweils um eins erhöhen wollen. Angenommen der Zähler hat zu Beginn den
Wert drei. Beide Threads wollen jetzt nahezu gleichzeitig den Zähler um eins
erhöhen. Dazu lesen beide Threads den aktuellen Wert des Zählers, in diesem Fall
drei, aus. Anschließend addieren beide eins hinzu und schreiben den neuen Wert,
in diesem Fall vier, in den Zähler. Erwartet wurde jedoch der Wert fünf, da
beide Threads den Zähler um jeweils eins erhöhen sollten. Um solche \textit{race
conditions} zu verhindert werden Synchronisierungsmechanismen benötigt.

Eine Möglichkeit um den Zugriff auf eine gemeinsame Ressource zu synchronisieren
sind Locks. Ein Lock ist ein exklusiver Zugriff auf ein Objekt, ein sogenanntes
Lockobjekt. Das bedeutet, dass während ein Thread einen Lock auf ein Objekt
besitzt, andere Threads, welche auf dasselbe Objekt zugreifen wollen, warten
müssen bis es freigegeben wurde.

Betrachtet man das Beispiel mit dem Zähler erneut, dieses Mal mit Locks als
Synchronisationsmittel, kann es zu folgender Ausführung kommen. Der Zähler hat
zu Beginn wieder den Wert drei. Die Threads \textit{T1} und \textit{T2} wollen
erneut den Zähler nahezu gleichzeitig erhöhen. Dieses Mal versuchen beide das
Lockobjekt \textit{L1} in Besitz zu nehmen. Der Thread \textit{T2} nimmt
\textit{L1} zuerst in Besitz, daraus folgt \textit{T1} muss warten. \textit{T2}
liest den aktuellen Wert des Zählers aus, erhöht diesen um eins und schreibt den
neuen Wert vier in den Zähler. Anschließend gibt \textit{T2} das Lockobjekt
\textit{L1} frei. Jetzt erhält der Thread \textit{T1} den Zugriff auf
\textit{L1} und liest ebenfalls den Zähler, jetzt vier, aus, erhöht diesen und
schreibt den neuen Wert fünf in den Zähler. Anschließend gibt \textit{T1} das
Lockobjekt \textit{L1} frei.

Die Verwendung von Locks in Verbindung mit der nicht deterministischen
Ausführung von Multithreaded Anwendungen, kann zu folgender Situation führen:
Angenommen es existieren zwei Threads \textit{T1} und \textit{T2} und zwei
Lockobjekte \textit{L1} und \textit{L2}. Angenommen \textit{T1} besitzt
\textit{L1} und zu gleichen Zeit erlangt \textit{T2} das Lockobjekt \textit{L2}.
Wenn jetzt der Thread \textit{T1} das Lockobjekt \textit{L2} anfordert und der
Thread \textit{T2} das Lockobjekt \textit{L1}, kommt es zu einem
\textit{Deadlock}. Die Ausführung des Programms terminiert nicht, da beide
Threads auf den jeweils anderen Thread warten und sich gegenseitig blockieren.

Solche potenziellen Deadlocks zu erkennen ist die Aufgabe von statischen und
dynamischen Methoden zur Deadlockerkennung. Die statische Deadlockerkennung
analysiert den Quellcode und wird hier nicht näher betrachtet. Die dynamische
Deadlockerkennung analysiert eine Anwendung zur Laufzeit und läuft in folgenden
drei Schritten ab:
\begin{enumerate}
  \item Erstellung einer Trace-Datei
  \item Erstellung eines Graphens basierend auf den Informationen aus der
  Trace-Datei
  \item Finden von potenziellen Deadlocks durch das Identifizieren von Zyklen
  innerhalb des Graphens
\end{enumerate}

Eine Trace-Datei enthält einen \textit{execution trace} des ausführenden
Programms. Ein \textit{execution trace} ist eine Abfolge von Events. Ein Event
\textit{e\textsubscript{i}} wird durch eine der folgenden Methoden definiert:
starten eines Threads, Inbesitznahme eines Lockobjekts und Freigabe eines
Lockobjekts. Das Starten eines neues Threads ist definiert durch:
\begin{quote}
\texttt{s(Programmstelle, ausführender Thread, Name des neuen Threads)}
\end{quote}
Zum Beispiel bedeutet \texttt{s(2,main,T1)}, dass an der Programmstelle
\textit{2} der Thread \textit{main} den Thread \textit{T1} gestartet hat. 
Die Inbesitznahme eines Lockobjekts ist definiert durch:
\begin{quote}
\texttt{l(Programmstelle, ausführender Thread, Name des Lockobjekts)}
\end{quote}
Zum Beispiel bedeutet \texttt{l(24,T1,L3)}, dass
an der Programmstelle \textit{24} hat der Thread \textit{T1} das Lockobjekt
\textit{L3} in Besitz genommen. Die Freigabe eines Lockobjekts ist definiert
durch:
\begin{quote}
\texttt{u(Programmstelle, ausführender Thread, Name des Lockobjekts)}
\end{quote}
Zum Beispiel bedeutet \texttt{u(30, T1, L3)}, dass an der Programmstelle
\textit{30} der Thread \textit{T1} das Lockobjekt \textit{L3} freigegeben hat.

Die Menge aller während der Laufzeit des Programms aufgetretenen Events
definieren einen möglichen \textit{execution trace} des Programms.
Programme welche mit mehreren Threads arbeiten, haben keinen deterministischen
\textit{execution trace}. Jede Ausführung eines solchen Programms kann zu
unterschiedlichen \textit{execution traces} führen. 

Im zweiten Schritt wird aus dem vorher erzeugten \textit{execution trace} ein
Lockgraph erstellt. Ein Lockgraph ist definiert durch:
\begin{quote}
\textit{LG = (L,R)}
\end{quote}
\textit{L} ist die Menge aller Lockobjekte im \textit{execution trace} und
\textit{R} die Menge aller Lockpaare. Ein Lockpaar ist definiert durch das Tupel
\textit{(l\textsubscript{1}, l\textsubscript{2})} für das gilt: Es existiert ein
Thread, welcher das Lockobjekt \textit{l\textsubscript{1}} besitzt, während er
den Lock \textit{l\textsubscript{2}} anfordert.

% \lstinputlisting[caption={Beispiel einer
% OpenPEARL Anwendung mit einem potenziellen Deadlock},
% label={lst:ExampleDeadlock}]{./Examples/Example_Deadlock.prl}

In ??? ist ein Beispielprogramm in der Programmiersprache
OpenPEARL dargestellt.

\section{Evaluierung von Methoden zur dynamischen Deadlockerkennung}
\label{section:Evaluierung von Methoden zur dynamischen Deadlockerkennung}

\section{Ergebnis}
\label{section:Ergebnis}
\begin{itemize}
  \item Auswahl MagicLock\autocite{MagicLock}
\end{itemize}
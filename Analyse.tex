\section{Deadlockerkennung allgemein}
\label{section:Deadlockerkennung allgemein}
Im Gegensatz zu Single-Threaded-Applikationen sind Multi-Threaded-Anwendungen
nicht deterministisch. Dies kann zu \textit{race conditions} führen. Eine
\textit{race condition} tritt zum Beispiel dann auf, wenn zwei Threads einen
Zähler jeweils um eins erhöhen wollen. Angenommen der Zähler hat zu Beginn den
Wert drei. Beide Threads wollen jetzt nahezu gleichzeitig den Zähler um eins
erhöhen. Dazu lesen beide Threads den aktuellen Wert des Zählers, in diesem Fall
drei, aus. Anschließend addieren beide eins hinzu und schreiben den neuen Wert,
in diesem Fall vier, in den Zähler. Erwartet wurde jedoch der Wert fünf, da
beide Threads den Zähler um jeweils eins erhöhen sollten. Um solche \textit{race
conditions} zu verhindert werden Synchronisierungsmechanismen benötigt.

Eine Möglichkeit um den Zugriff auf eine gemeinsame Ressource zu synchronisieren
sind Locks. Ein Lock ist ein exklusiver Zugriff auf ein Objekt, ein sogenanntes
Lockobjekt. Das bedeutet, dass während ein Thread einen Lock auf ein Objekt
besitzt, andere Threads, welche auf dasselbe Objekt zugreifen wollen, warten
müssen bis es freigegeben wurde.

Betrachtet man das Beispiel mit dem Zähler erneut, dieses Mal mit Locks als
Synchronisationsmittel, kann es zu folgender Ausführung kommen. Der Zähler hat
zu Beginn wieder den Wert drei. Die Threads \textit{T1} und \textit{T2} wollen
erneut den Zähler nahezu gleichzeitig erhöhen. Dieses Mal versuchen beide das
Lockobjekt \textit{L1} in Besitz zu nehmen. Der Thread \textit{T2} nimmt
\textit{L1} zuerst in Besitz, daraus folgt \textit{T1} muss warten. \textit{T2}
liest den aktuellen Wert des Zählers aus, erhöht diesen um eins und schreibt den
neuen Wert vier in den Zähler. Anschließend gibt \textit{T2} das Lockobjekt
\textit{L1} frei. Jetzt erhält der Thread \textit{T1} den Zugriff auf
\textit{L1} und liest ebenfalls den Zähler, jetzt vier, aus, erhöht diesen und
schreibt den neuen Wert fünf in den Zähler. Anschließend gibt \textit{T1} das
Lockobjekt \textit{L1} frei.

Die Verwendung von Locks in Verbindung mit der nicht deterministischen
Ausführung von Multi-Threaded-Anwendungen, kann zu folgender Situation führen:
Angenommen es existieren zwei Threads \textit{T1} und \textit{T2} und zwei
Lockobjekte \textit{L1} und \textit{L2}. Angenommen \textit{T1} besitzt
\textit{L1} und zu gleichen Zeit erlangt \textit{T2} das Lockobjekt \textit{L2}.
Wenn jetzt der Thread \textit{T1} das Lockobjekt \textit{L2} anfordert und der
Thread \textit{T2} das Lockobjekt \textit{L1}, kommt es zu einem
\textit{Deadlock}. Die Ausführung des Programms terminiert nicht, da beide
Threads auf den jeweils anderen Thread warten und sich gegenseitig blockieren.

Solche potenziellen Deadlocks zu erkennen ist die Aufgabe von statischen und
dynamischen Methoden zur Deadlockerkennung. Die statische Deadlockerkennung
analysiert den Quellcode und wird hier nicht näher betrachtet. Die dynamische
Deadlockerkennung analysiert eine Anwendung zur Laufzeit und läuft in folgenden
drei Schritten ab:
\begin{enumerate}
  \item Erstellung einer Trace-Datei
  \item Erstellung eines Graphen basierend auf den Informationen aus der
  Trace-Datei
  \item Finden von potenziellen Deadlocks durch das Identifizieren von Zyklen
  innerhalb des Graphen
\end{enumerate}

Eine Trace-Datei enthält einen \textit{execution trace} des ausführenden
Programms. Ein \textit{execution trace} ist eine Abfolge von Events. Ein Event
\textit{e\textsubscript{i}} wird durch eine der folgenden Methoden definiert:
starten eines Threads, Inbesitznahme eines Lockobjekts und Freigabe eines
Lockobjekts. Das Starten eines neues Threads ist definiert durch:
\begin{quote}
\texttt{s(Programmstelle, ausführender Thread, Name des neuen Threads)}
\end{quote}
Zum Beispiel bedeutet \texttt{s(2,main,T1)}, dass an der Programmstelle
\textit{2} der Thread \textit{main} den Thread \textit{T1} gestartet hat. 
Die Inbesitznahme eines Lockobjekts ist definiert durch:
\begin{quote}
\texttt{l(Programmstelle, ausführender Thread, Name des Lockobjekts)}
\end{quote}
Zum Beispiel bedeutet \texttt{l(24,T1,L3)}, dass
an der Programmstelle \textit{24} hat der Thread \textit{T1} das Lockobjekt
\textit{L3} in Besitz genommen. Die Freigabe eines Lockobjekts ist definiert
durch:
\begin{quote}
\texttt{u(Programmstelle, ausführender Thread, Name des Lockobjekts)}
\end{quote}
Zum Beispiel bedeutet \texttt{u(30, T1, L3)}, dass an der Programmstelle
\textit{30} der Thread \textit{T1} das Lockobjekt \textit{L3} freigegeben hat.

Die Menge aller während der Laufzeit des Programms aufgetretenen Events
definieren einen möglichen \textit{execution trace} des Programms.
Programme welche mit mehreren Threads arbeiten, haben keinen deterministischen
\textit{execution trace}. Jede Ausführung eines solchen Programms kann zu
unterschiedlichen \textit{execution traces} führen. 

Im zweiten Schritt wird aus dem vorher erzeugten \textit{execution trace} ein
Lockgraph erstellt. Ein Lockgraph ist definiert durch:
\begin{quote}
\textit{LG = (L,R)}
\end{quote}
\textit{L} ist die Menge aller Lockobjekte im \textit{execution trace} und
\textit{R} die Menge aller Lockpaare. Ein Lockpaar ist definiert durch das Tupel
\textit{(l\textsubscript{1}, l\textsubscript{2})} für das gilt: Es existiert ein
Thread, welcher das Lockobjekt \textit{l\textsubscript{1}} besitzt, während er
den Lock \textit{l\textsubscript{2}} anfordert.

\section{PEARL}
\label{section:PEARL}
\begin{itemize}
    \item Kurze Beschreibung der Programmiersprache PEARL
    \item Aufzeigen der Möglichkeiten von Synchronisationsmitteln in PEARL
\end{itemize}

\begin{listing}[ht]
  \inputminted[frame=lines,linenos]{vim}{./Examples/Example_Deadlock.prl}
  \caption{Beispiel einer OpenPEARL Anwendung mit einem potenziellen Deadlock}    
  \label{lst:ExampleDeadlock}   
\end{listing} 

In \cref{lst:ExampleDeadlock} ist ein Beispielprogramm in der Programmiersprache
PEARL dargestellt. Das Programm startet zwei parallele Aufgaben welche beide eine Zeichenfolge auf der Standardausgabe ausgeben. Der Zugriff auf die Standardausgabe muss dabei synchronisiert erfolgen.

In den Zeilen 1 bis 11 werden Variablen definiert, wie zum Beispiel die Ausgabe über die Standardausgabe und die zwei \textit{SEMA} Variablen \textit{L1} und \textit{L2} in den Zeilen 9 und 10. Ein \textit{SEMA} Objekt ist ein Semaphore und dient als Synchronisationsmittel. Es kann als Wert nicht negative ganze Zahlen besitzen, wobei null den Zustand "gesperrt" und positive Zahlen den Zustand "frei" bedeuten \autocite[9--17]{PEARL}. Eine \textit{SEMA} Variable hat zu Beginn den Wert null und den Zustand "gesperrt". In den Zeilen 12 bis 17 ist ein \textit{TASK} definiert. Durch die Kennzeichnung \textit{MAIN} wird der \textit{TASK} direkt beim Start des Programms ausgeführt. Die Befehle \textit{RELEASE} in den Zeilen 13 und 14 erhöhen den Wert der jeweiligen \textit{SEMA} Variable um eins, wodurch der Zustand von "gesperrt" auf "frei" gesetzt wird. Anschließend werden in den Zeilen 15 und 16 die \textit{TASKS} \textit{T2} und \textit{T3} gestartet.

Die \textit{TASKS} \textit{T2} und \textit{T3} geben in den Zeilen 22 bis 24 und in den Zeilen 32 bis 34 die Zeichenfolge "Hello World T2" bzw. "Hello World T3" auf der Standardausgabe aus. Die Synchronisierung des Zugriffs auf die Standardausgabe erfolgt mittels den \textit{SEMA} Variablen \textit{L1} und \textit{L2}. Mit dem \textit{REQUEST} Befehl wird der Wert einer \textit{SEMA} Variable um eins verringert. Ist der Wert einer \textit{SEMA} Variable null wird der \textit{TASK} angehalten und in eine Warteschlange eingereiht. Sobald die Variable über den Befehl \textit{RELEASE} wieder freigeben wird, wird der nächste \textit{TASK} in der Warteschlange gemäß seiner Priorität fortgeführt. Beide \textit{TASKS} versuchen beide \textit{SEMA} Variablen in Besitz zu nehmen. \textit{T2} versucht in den Zeilen 20 und 21 zuerst \textit{L1} und dann \textit{L2} in Besitz zu nehmen. \textit{T3} versucht in den Zeilen 30 und 31 zuerst \textit{L2} und dann \textit{L1} in Besitz zu nehmen. Da beide \textit{TASKS} parallel laufen, kann es passieren, dass \textit{T2} \textit{L1} in Zeile 20 in Besitz nimmt und gleichzeitig \textit{T3} in Zeile 30 \textit{L2} in Besitz nimmt. Beide \textit{SEMA} Variablen haben jetzt den Wert null und den Zustand "gesperrt". Der \textit{TASK} \textit{T2} wartet jetzt darauf, dass \textit{L2} freigegeben wird und \textit{T3} wartet darauf, dass \textit{L1} freigegeben wird. Beide \textit{TASKS} warten auf den jeweils anderen. Diese Situation wird als Deadlock bezeichnet.

\section{MagicLock}
\label{section:MagicLock}
\begin{itemize}
  \item Beschreibung des MagicLock\autocite{MagicLock} Algorithmus
\end{itemize}
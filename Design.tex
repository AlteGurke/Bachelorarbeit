\section{Übersicht}
\label{section:Übersicht}
Die OpenPEARL Laufzeitumgebung wird um eine Trace-Funktionalität für \emph{SEMA}
Objekte erweitert. Dazu wird die \emph{SEMA} Implementierung in der OpenPEARL
Laufzeitumgebung angepasst. Diese Trace-Funktionalität wird über eine
Umgebungsvariable gesteuert. Das Schreiben auf die Festplatte ist sehr
zeitintensiv, deswegen werden Lockereignisse zwischengespeichert und erst beim
Erreichen eines definierten Werts in die Trace-Datei geschrieben. Dieser Wert
wird ebenfalls über eine Umgebungsvariable definiert.

Die erzeugte Trace-Datei dient als Eingabe für die Anwendung zur Generierung und
Darstellung der chronologischen Verwendung der \emph{SEMA} Objekte.

Zusätzlich wird die Trace-Datei mit Hilfe des MagicLock\footnote{Siehe
\cref{section:MagicLock}} Algorithmus nach potentiellen Deadlocks durchsucht.
Potentielle Deadlocks werden anschließend als gerichteter Graph dargestellt.

\section{Erzeugung der Trace-Datei}
\label{section:Erzeugung der Trace-Datei}
In der Trace-Datei werden alle benötigten Informationen geschrieben, um
potentielle Deadlocks zu erkennen:
\begin{enumerate}
  \item Der genaue Zeitpunkt des Ereignisses 
  \item Die Art des Ereignisses (Lock, Unlock)
  \item Der Name des ausführenden Threads
  \item Der Name des verwendeten Lockobjekts
\end{enumerate}

In \cref{fig:LockTrace_Design} sind die benötigten Klassen dargestellt.
\begin{figure}[ht]
  \includegraphics[width=\linewidth]{LockTrace_Design.eps}
  \footnotesize\sffamily\textbf{Quelle:} Eigene Darstellung
  \caption{UML Klassendiagramm für Trace-Funktionalität}
  \label{fig:LockTrace_Design}
\end{figure}
Die notwendigen Informationen für einen Trace-Eintrag werden in der Klasse
\texttt{Lock\-Trace\-Entry} gehalten. Für den Zeitunkt wird der Typ 
\texttt{chrono::\-time\_point} vom Typ \texttt{chrono::\-high\_resolution\_clock}
verwendet. Der Typ \texttt{chrono::\-high\_resolution\_clock} stellt einen
Zeitpunkt mit der höchstmöglichen Genauigkeit der jeweiligen Implementierung
dar\footnote{C++ ab der Version 11}. Für die spätere Visualisierung ist eine
hohe Genauigkeit notwendig, um nahezu parallel aufgetretene Lockereignisse
chronologisch getrennt visualisieren zu können. Die Klasse
\texttt{Lock\-Trace\-Entry\-Formatter} erstellt mit der Methode
\texttt{Format\-Lock\-Trace\-Entry} aus einem \texttt{Lock\-Trace\-Entry} eine
Zeichenkette, die einer Zeile in der Trace-Datei entspricht. Diese Klasse wird
als Singleton implementiert, da zur Laufzeit immer nur genau eine Instanz
benötigt wird. Die Klasse \texttt{Lock\-Tracer} stellt die Methode \texttt{Add}
zur Verfügung, welche von der OpenPEARL Laufzeitumgebung aufgerufen wird. Mit
Hilfe der Methode können Lockereignisse erstellt werden. Die Methode
\texttt{IsEnabled} gibt den aktuellen Zustand der \texttt{Lock\-Tracer} Instanz
zurück. Mithilfe dieser Methode kann ein Aufrufer prüfen, ob die
Trace-Funktionalität aktiviert ist. Ist dies nicht der Fall, muss die
\texttt{Add} Methode nicht aufgerufen und somit auch kein
\texttt{Lock\-Trace\-Entry} Objekt erzeugt werden. Die Klasse wird ebenfalls als
Singleton implementiert, damit nur eine Instanz zur Laufzeit verwendet werden
kann. Das Speichern der Ereignisse in die Trace-Datei ist kostspielig und soll
daher nicht für jeden Eintrag gemacht werden. Die Klasse \texttt{Lock\-Tracer}
reiht dazu die einzelnen Lockereignisse, welche über die \texttt{Add} Methode
hinzugefügt werden, in eine Warteschlange ein. Sobald eine spezifizierte Anzahl
erreicht ist, wird die Warteschlange geleert und in die Trace-Datei geschrieben.
Die Anzahl kann über die Umgebungsvariable
\texttt{OpenPEARL\_LockTracer\_MaxEntries} spezifiziert werden. Die
Umgebungsvariable wird bei der Initialisierung der \texttt{Lock\-Tracer}
Implementierung ausgelesen und in der Variable \texttt{number\-Of\-Max\-Entries}
gespeichert. Das Hinzufügen der Ereignisse in die Warteschlange kann parallel
erfolgen und muss daher Thread sicher implementiert werden. Eine Möglichkeit
wäre, die einzelnen Zugriffe über einen Lock zu synchronisieren. Dies würde die
Laufzeit der Anwendung stark negativ beeinflussen. Deswegen wird die lock freie
Implementierung einer Warteschlange aus \autocite{Moody_Camels_Concurrentqueue}
verwendet. Die Warteschlange garantiert eine Thread sichere Implementierung,
aber keine Sortierung innerhalb der Warteschlange für mehrere
Produzenten.\footnote{Vgl. \autocite{Moody_Camels_Concurrentqueue}} Da es zur
Laufzeit nur eine einzige Instanz der \texttt{Lock\-Tracer} Klasse gibt, ist die
Reihenfolge innerhalb der Warteschlange dennoch garantiert. Der Dateipfad zur
Speicherung der Trace-Datei wird über die Umgebungsvariable
\texttt{OpenPEARL\_LockTracer\_Path} definiert und bei der Initialisierung der
\texttt{LockTracer} Implementierung in der Variable \texttt{filePath}
gespeichert. Die dritte Umgebungsvariable
\texttt{OpenPEARL\_LockTracer\_Enabled} wird zur Aktivierung der
Trace-Funktionalität verwendet. Wenn die Umgebungsvariable gesetzt ist und den
Wert \texttt{true} hat, wird die Trace-Funktionalität aktiviert. Ansonsten
werden alle Aufrufe zur \texttt{Add} Methode direkt über eine \texttt{return}
Anweisung beendet. Dadurch wird die Laufzeit der Anwendung bei deaktivierter
Trace-Funktionalität nicht beeinflusst.

In der OpenPEARL Laufzeitumgebung werden die \emph{REQUEST} und \emph{RELEASE}
Anweisungen in der Semaphor Implementierung unter runtime/common/Semaphore.cc
implementiert. Bei einer Erhöhung auf eins oder einer Verringerung auf null
eines Semaphors muss ein Lockereignis erzeugt werden. Bei einer Erhöhung auf
eins muss der \texttt{Lock\-Trace\-Entry\-Type} \texttt{Unlock} bei einer
Verringerung auf null der \texttt{Lock\-Trace\-Entry\-Type} \texttt{Lock}
verwendet werden. Die Klassen für die Implementierung des LockTracers müssen bei
der Kompilierung der OpenPEARL Laufzeitumgebung mit einbezogen werden. In der
Datei runtime/common/Files.common sind alle Dateien aufgeführt, welche bei der
Kompilierung einbezogen werden. Dort müssen die Dateien, die aus
\cref{fig:LockTrace_Design} entstehen eingetragen werden.

\section{Analysieren der Trace-Datei}
\label{section:Analysieren der Trace-Datei}
Als Eingabe dient die in \cref{section:Erzeugung der Trace-Datei} erzeugte
Trace-Datei. Die chronologische Darstellung wird, wie in
\cref{fig:Timeline_Example} skizziert, über einen zwei dimensionalen Graphen
realisiert. Die Ordinate bildet die Zeit ab, wobei nur das Delta in
Mikrosekunden zwischen den einzelnen Ereignissen dargestellt wird. Für jeden
Thread wird ein Eintrag auf der Abszisse gemacht. Es wird zwischen zwei
Ereignissen unterschieden. Wird ein \emph{SEMA} Objekt in Besitz genommen wird
ein roter und für das Freigeben eines \emph{SEMA} Objekts ein grüner Kreis
gezeichnet. Die Beschriftung eines Kreises enthält den Namen des \emph{SEMA}
Objekts.
\begin{figure}[ht]
  \includegraphics[width=\linewidth]{Timeline_Example.eps}
  \footnotesize\sffamily\textbf{Quelle:} Eigene Darstellung
  \caption{Visualisierung der chronologischen Verwendung von \emph{SEMA} Objekten}
  \label{fig:Timeline_Example}
\end{figure}

\section{Erweiterung: Potenzielle Deadlocks}
\label{section:Erweiterung: Potenzielle Deadlocks}
Der in \cref{section:MagicLock} beschrieben Algorithmus wird dazu verwendet, um
potentielle Deadlocks in der aus \cref{section:Erzeugung der Trace-Datei}
erstellten Trace-Datei zu finden. 
\begin{figure}[ht]
  \includegraphics[width=\linewidth/2]{Magiclock_Example.eps}
  \footnotesize\sffamily\textbf{Quelle:} Eigene Darstellung
  \caption{Visualisierung eines potentiellen Deadlocks}
  \label{fig:Magiclock_Example}
\end{figure}

Potentielle Deadlocks werden wie in \cref{fig:Magiclock_Example} skizziert als
gerichteter Graph dargestellt. Knoten repräsentieren Lockobjekte, Kanten
repräsentieren die Inbesitznahme eines Lockobjekts und die Beschriftung an einer
Kante bezeichnet den ausführenden Thread. In dem skizzierten Beispiel existiert
ein potentieller Deadlock zwischen den Threads \emph{T1} und \emph{T2}. Der
Thread \emph{T1} nimmt das Lockobjekt \emph{L2} in Besitz während dieser bereits
\emph{L1} besitzt. Dies ist zu erkennen an der Kante vom Knoten \emph{L1} zum
Knoten \emph{L2} mit der Bezeichnung \emph{T1}. Der Thread \emph{T2} nimmt in
dem Beispiel das Lockobjekt \emph{L1} in Besitz während dieser bereits \emph{L2}
besitzt. Dies kann zu einem Deadlock führen, wenn \emph{T1} das Lockobjekt
\emph{L1} und \emph{T2} das Lockobjekt \emph{L2} gleichzeitig besitzen.
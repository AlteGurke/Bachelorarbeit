\section{Erzeugung der Trace-Datei}
\label{section:Erzeugung der Trace-Datei}
Im ersten Schritt wird eine Trace-Datei während der Laufzeit der Anwendung
erzeugt. Die Datei enthält alle benötigten Informationen, um potentielle
Deadlocks zu erkennen:

\begin{enumerate}
  \item Der genaue Zeitpunkt des Ereignisses 
  \item Die Art des Ereignisses (Lock, Unlock)
  \item Die Id des ausführenden Threads
  \item Der Name des betroffenen Lockobjekts
\end{enumerate}

\begin{figure}[ht]
  \includegraphics[width=\linewidth]{LockTrace_Design.eps}
  \caption{UML Klassendiagramm für die benötigten Informationen der Trace-Datei}
  \label{fig:LockTrace_Design}
\end{figure}

In \cref{fig:LockTrace_Design} sind die benötigten Klassen dargestellt. Die
notwendigen Informationen für einen Trace-Eintrag werden in der Klasse
\texttt{LockTraceEntry} gehalten. Für den Zeitunkt wird der Typ 
\texttt{chrono::time\_point} vom Typ \texttt{chrono::high\_resolution\_clock}
verwendet. Der Typ \texttt{chrono::high\_resolution\_clock} stellt einen
Zeitpunkt mit der höchstmöglichen Genauigkeit der jeweiligen Implementierung dar
{TODO: Referenz auf C++11}. Für die spätere Visualisierung ist eine hohe
Genauigkeit notwendig, um nahezu parallel aufgetretene Lock-Ereignisse
chronologisch getrennt visualisieren zu können. Die Klasse
\texttt{LockTraceEntryFormatter} erstellt mit der Methode
\texttt{FormatLogTraceEntry} aus einem \texttt{LockTraceEntry} eine
Zeichenkette, welche einer Zeile in der Trace-Datei entspricht. Diese Klasse
wird als Singleton implementiert, da zur Laufzeit immer nur genau eine Instanz
benötigt wird. Die Klasse \texttt{LockTracer} stellt die Methode \texttt{Add}
zur Verfügung, welche von der OpenPEARL Laufzeitumgebung aufgerufen wird. Mit
Hilfe der Methode können Lock-Ereignisse erstellt werden. Die Klasse wird
ebenfalls als Singleton implementiert, damit nur eine Instanz zur Laufzeit
verwendet werden kann. Das Speichern der Ereignisse in die Trace-Datei ist
kostspielig und soll daher nicht für jeden Eintrag gemacht werden. Die Klasse
\texttt{LockTracer} reiht dazu die einzelnen Lock-Ereignisse, welche über die
\texttt{Add} Methode hinzugefügt werden, in eine Warteschlange ein. Sobald eine
spezifizierte Anzahl erreicht ist, wird die Warteschlange geleert und in die
Trace-Datei geschrieben. Die Anzahl kann über die Umgebungsvariable
\texttt{OpenPEARL\_LockTracer\_MaxEntries} spezifiziert werden. Die
Umgebungsvariable wird bei der Initialisierung der \texttt{LockTracer}
Implementierung ausgelesen und in der Variable \texttt{numberOfMaxEntries}
gespeichert. Das Hinzufügen der Ereignisse in die Warteschlange kann parallel
erfolgen und muss daher Thread sicher implementiert werden. Eine Möglichkeit
wäre, die einzelnen Zugriffe über einen Lock zu synchronisieren. Dies würde die
Laufzeit der Anwendung stark negativ beeinflussen. Deswegen wird eine lock freie
Implementierung einer Warteschlange verwendet
\autocite{Moody_Camels_Concurrentqueue}. Die Warteschlange garantiert eine
Thread sichere Implementierung, aber keine Sortierung innerhalb der
Warteschlange. Es kann passieren, dass Lock-Ereignisse in einer anderen
Reihenfolge aus der Warteschlange herausgenommen werden als sie eingefügt
wurden. Beim Auslesen der Trace-Datei muss daher anfangs eine Sortierung der
Einträge gemäß ihres Zeitpunkts durchgeführt werden. Der Dateipfad zur
Speicherung der Trace-Datei wird über die Umgebungsvariable
\texttt{OpenPEARL\_LockTracer\_Path} definiert und bei der Initialisierung der
\texttt{LockTracer} Implementierung in der Variable \texttt{filePath}
gespeichert. Die dritte Umgebungsvariable
\texttt{OpenPEARL\_LockTracer\_Enabled} wird zur Aktivierung der
Trace-Funktionalität verwendet. Wenn die Umgebungsvariable gesetzt ist und den
Wert \texttt{true} hat, wird die Trace-Funktionalität aktiviert. Ansonsten
werden alle Aufrufe zur \texttt{Add} Methode direkt über eine \texttt{return}
Anweisung beendet. Dadurch wird die Laufzeit der Anwendung bei deaktivierter
Trace-Funktionalität nicht beeinflusst.

In der OpenPEARL Laufzeitumgebung werden die \textit{REQUEST} und
\textit{RELEASE} Anweisungen in der Semaphore Implementierung unter
runtime/common/Semaphore.cc implementiert.

\begin{itemize}
    \item Definition der notwendigen Informationen der Trace-Datei
    \item Aufzeigen der Herausforderungen in Bezug auf Performance und
    Speicherauslastung
  \item Anforderungen definieren:
  \begin{itemize}
    \item Laufzeit des Programms soll sich um maximal x\% erhöhen
    \item Speicherauslastung des Programms soll sich um maximal y\% erhöhen
  \end{itemize}
    \item Aktuelle Idee: Das Erstellen der Trace-Datei wird in der
    Laufzeitumgebung umgesetzt. Die Implementierung erfolgt in einer eigenen
    Klasse und kann aktiviert oder deaktiviert sein. Die Klasse wird von der
    Semaphore Implementierung der Laufzeitumgebung verwendet werden. Beim Aufruf
    von Request oder Release wird geprüft, ob die Informationen geloggt werden
    sollen. Falls das Logging aktiviert ist, werden die Informationen in eine
    Warteschlange eingereiht. Die Warteschlange wird eine Datenstruktur
    verwendet, welche das Hinzufügen, Entfernen und das Abfragen der aktuellen
    Größe mit der Komplexität O(1) implementiert. Bei jeder x-ten Aktivierung,
    wobei x die maximale Größe der Warteschlange ist, werden alle vorhanden
    Einträge aus der Warteschlange entfernt und in die Trace-Datei geschrieben.
    Die Liste wird für jeden Eintrag einmal durchlaufen. Die Laufzeit beträgt
    daher O(x). Das Öffnen und Schließen der Trace-Datei hat die Laufzeit y. Das
    Schreiben eines Logeintrags, also eine Zeile in die Trace-Datei, hat die
    Laufzeit z. Damit hat jeder x-te Request/Release Aufruf die Laufzeit O(y + x
    $\cdot$ z). Somit hat jeder Request/Release Aufruf die Laufzeit O($\frac{y +
    x \cdot z}{x}$).

    Zusätzlich zu jedem x-ten Request/Release Aufruf das Schreiben in die
    Trace-Datei auch zeitich angestoßen werden. Zum Beispiel sollte alle 60
    Sekunden oder nach x Aufrufen die Warteschlange geleert und in die
    Trace-Datei geschrieben werden. Bei jedem x-ten Request/Release Aufruf muss
    der Timer der Warteschlange wieder zurückgesetzt werden. Bedeutet wenn nach
    50 Sekunden der x-te Aufruf kommt, muss der Timer wieder von vorne beginnen,
    damit die Trace-Datei nicht nach 10 Sekunden erneut beschrieben wird.

    Der zusätzliche Speicherbedarf beträgt $x \cdot i$, wobei i die Größe der
    Information eines Logeintrags entspricht. Ein Logeintrag benötigt die
    Informationen:
    \begin{enumerate}
      \item Aktion (Thread Start, Request, Release) => 32 Bit (enum)
      \item ID des Threads => 16-Bit Ganzzahl (maximale Thread Id für Linux
      beträgt 32768) theoretisch über 15 Bit abbildbar, da immer positiv
      \item Name des Lockobjekts => 16-Bit Ganzzahl (theoretisch über 11 Bit
      Ganzzahl abbildbar) (maximal Variablennamenlänge für C++ beträgt 2048)
    \end{enumerate}
    Mindestgröße für i beträgt 32 + 16 + 16 = 64 Bit. Die Warteschlange benötigt
    maximal daher 64 Bit $\cdot$ x zusätzlichen Speicher.
\end{itemize}

\section{Analysieren der Trace-Datei}
\label{section:Analysieren der Trace-Datei}
\begin{itemize}
  \item Externes Programm geschrieben in Java
  \item Anforderungen definieren:
  \begin{itemize}
    \item Darstellung der Trace-Datei (welcher Thread hat welches
    Synchronisationsmittel wann genommen und wieder freigegeben) 
  \end{itemize}
\end{itemize}

\section{Erweiterung: Potenzielle Deadlocks}
\label{section:Erweiterung: Potenzielle Deadlocks}
\begin{itemize}
  \item Programm aus \cref{section:Analysieren der Trace-Datei} wird erweitert
  \item Es sollen potenzielle Deadlocks mit Hilfe des aus \cref{section:MagicLock}
 beschriebenen Verfahrens bestimmt werden
  \item Potenzielle Deadlocks sollen als gerichtete Graphen visualisiert werden
\end{itemize}
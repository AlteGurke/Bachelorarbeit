\section{Trace Funktion}
\label{section:Implementierung:Trace Funktion}
Aus dem in \cref{fig:LockTrace_Design} vorgestellten UML-Diagramm werden drei
Klassen und eine Enumeration in C++ implementiert.
\texttt{Lock\-Trace\-Entry\-Type} wird als \texttt{enum} mit den Werten
\texttt{Lock} und \texttt{Unlock} implementiert. Die Klasse
\texttt{LockTraceEntry} wird als einfache Datenklasse mit Get-Methoden für jedes
Attribut implementiert. Die beiden Klassen \texttt{Log\-Trace\-Entry\-Formatter}
und \texttt{LogTracer} werden als Singleton implementiert. Die Implementierung
für die Berechnung des genauen Zeitpunkts ist in
\cref{lst:LockTraceEntryFormatter_FormatLogTraceEntry} dargestellt.

\begin{listing}[ht]
  \inputminted[frame=lines,linenos,firstline=31,lastline=33]{cpp}{./cpp/LockTraceEntryFormatter.cc}
  \caption{Auszug aus LockTraceEntryFormatter.cc: Berechnung des Zeitpunkts}
  \label{lst:LockTraceEntryFormatter_FormatLogTraceEntry}   
\end{listing}

Der \texttt{chrono::time\_point} wird in Mikrosekunden seit dem 01.01.1970
umgerechnet. Mikrosekunden wurden als Genauigkeit gewählt, weil Millisekunden
nicht hochauflösend genug sind, um die chronologische Verwendung von
Lockobjekten darzustellen. Eine höhere Auflösung als Mikrosekunden würde die
Darstellung hingegen zu unübersichtlich machen.

\begin{listing}[ht]
  \inputminted[frame=lines,linenos,firstline=11,lastline=54]{cpp}{./cpp/LockTracer.cc}
  \caption{LockTracer.cc: Auszug aus der Implementierung des LockTracers}
  \label{lst:LockTracer}
\end{listing}

In \cref{lst:LockTracer} ist ein Auszug aus der Implementierung der Klasse
\texttt{LockTracer} dargestellt. Die \texttt{GetInstance()} Methode stellt
sicher, dass nur eine Instanz der Klasse zur Laufzeit existiert TODO: Referenz
C++11. Im Konstruktor wird einmalig geprüft, ob die notwendigen
Umgebungsvariablen existieren und korrekte Werte aufweisen. Wenn alle Variablen
vorhanden und die Variable \texttt{Name\-Of\-Environment\-Variable\-Enabled} den
Wert \texttt{true} hat, wird die Trace-Funktionalität aktiviert. In der Methode
\texttt{Add(Lock\-Trace\-Entry\& entry)} wird zuerst geprüft, ob die
Trace-Funktionalität aktiviert ist. Ist dies nicht der Fall wird die Methode
sofort beendet, dadurch wird die Laufzeit der OpenPEARL Anwendung bei
deaktivierter Trace-Funktionalität nicht negativ beeinflusst\footnote{Der
einmalige Aufruf des Konstruktors, sowie der Aufruf der Add Methode und das
Prüfen eines booleschen Wertes werden hier ignoriert.}. Es wird sichergestellt,
dass beim Beenden der Anwendung alle noch vorhanden Logeinträge in die
Trace-Datei geschrieben werden. Dies erfolgt über den Destruktor der Klasse in
Zeile 48.

\section{Analyse Programm}
\label{section:Implementierung:Analyse Programm}
Die Implementierung für die Analyse und die chronologische Darstellung der
Verwendung von \textit{SEMA} Objekten wird in Python\footnote{Python Version
3.7.3.} durchgeführt. Im ersten Schritt wird die Trace-Datei aus
\cref{section:Erzeugung der Trace-Datei} ausgelesen. Die einzelnen Logeinträge
werden von der Klasse
\texttt{Lock\-Action} repräsentiert, welche in \cref{lst:TraceFileReader}
dargestellt ist.

\begin{listing}[ht]
  \inputminted[frame=lines,linenos,firstline=1,lastline=10]{python}{./Python/traceFileReader.py}
  \caption{traceFileReader.py: Auszug aus der Implementierung des Trace-Datei Parsers}
  \label{lst:TraceFileReader}
\end{listing}

Anschließend wird aus den ausgelesenen Logeinträgen ein Graph erstellt. Dazu
wird die Python-Bibliothek Matplotlib\footnote{Matplotlib Version 3.1.3.}
verwendet. In \cref{lst:GenerateTimeline_CreateGraphValues} ist die Erzeugung
des Graphen dargestellt.

\begin{listing}[ht]
  \inputminted[frame=lines,linenos,firstline=16,lastline=38]{python}{./Python/generateTimeline.py}
  \caption{generateTimeline.py: Auszug aus der Bestimmung der einzelnen Werte für den Graphen}
  \label{lst:GenerateTimeline_CreateGraphValues}
\end{listing}

In den Zeilen 23 bis 25 werden die Threads und Zeitstempel in Hashsets
gespeichert und anschließend in den Zeilen 27 und 28 sortiert. In den Zeilen 30
bis 38 werden die Werte für die einzelnen Logeinträge bestimmt. Um die Threads
auf der Ordinate abzubilden, wird in Zeile 36 der Index des jeweiligen Threads
im sortierten Hashset verwendet. Dadurch entspricht jeder ganzzahlige Wert auf
der Ordinate einem Thread. Falls es mehrere Einträge für eine Thread mit dem
gleichen Zeitstempel gibt, wird in den Zeilen 33 und 34 ein Offset berechnet und
in der Zeile 36 hinzugefügt, um eine Überlappung zu verhindern. Für den Wert auf
der Abszisse wird das Delta der Zeitstempel zwischen dem jeweiligen Logeintrag
und dem niedrigsten Zeitstempel in der Zeile 31 berechnet. In Zeile 37 wird die
Farbe des Logeintrags und in Zeile 38 die Beschriftung festgelegt. Aus den
einzelnen Werten wird in \cref{lst:GenerateTimeline_PlotGraph} der Graph mit
Matplotlib erstellt und kann dann mit dem Befehl \texttt{plt.show()} dargestellt
werden.

\begin{listing}[ht]
  \inputminted[frame=lines,linenos,firstline=42,lastline=44]{python}{./Python/generateTimeline.py}
  \caption{generateTimeline.py: Auszug aus der Erzeugung des Graphen}
  \label{lst:GenerateTimeline_PlotGraph}
\end{listing}

\section{Visualisierung von potenziellen Deadlocks}
\label{section:Implementierung:Visualisierung von potenziellen Deadlocks}
Im ersten Schritt wird der MagicLock-Algorithmus in Python\footnote{Python
Version 3.7.3.} implementiert. Das Auslesen der Trace-Datei wurde bereits in
\cref{section:Implementierung:Analyse Programm} durchgeführt und wird hier
wiederverwendet. Nach dem Auslesen werden die Logeinträge in eine \textit{Lock
Dependency Relation} überführt. Die Klassen sind in
\cref{lst:MagiclockTypes_LockDependency} und
\cref{lst:MagiclockTypes_LockDependencyRelation} dargestellt.

\begin{listing}[ht]
  \inputminted[frame=lines,linenos,firstline=45,lastline=49]{python}{./Python/magiclockLib/magiclockTypes.py}
  \caption{magiclockLib/magiclockTypes.py: Repräsentation einer \textit{Lock Dependency} aus Magiclock[3]\autocite{MagicLock}}
  \label{lst:MagiclockTypes_LockDependency}
\end{listing}
\begin{listing}[ht]
  \inputminted[frame=lines,linenos,firstline=67,lastline=77]{python}{./Python/magiclockLib/magiclockTypes.py}
  \caption{magiclockLib/magiclockTypes.py: Repräsentation einer \textit{Lock Dependency Relation} aus Magiclock[3]\autocite{MagicLock}}
  \label{lst:MagiclockTypes_LockDependencyRelation}
\end{listing}

Eine \texttt{LockDependencyRelation} enthält ein Hashset mit allen Lockobjekten,
eine Liste aller Threads und eine Liste der einzelnen \texttt{LockDependency}
Objekten. Für die Threads wurde eine Liste gewählt, damit die Ergebnisse
deterministisch ausfallen. Die Liste der Threads wird später in einer Schleife
durchlaufen. Dies führt bei einem Hashset zu nicht deterministischen Ergebnisse,
da die Sortierung zufällig ist.

Im zweiten Schritt wird die \texttt{LockDependencyRelation} reduziert. Dazu
werden die einzelnen Lockobjekte klassifiziert indem diese einer der folgenden
Mengen zugewiesen werden\autocite[4]{MagicLock}.

\begin{enumerate}
  \item \textbf{Independent-set} = $\{m \mid m \in Locks, indegree(m) = 0 \land
  outdegree(m) = 0\}$
  \item \textbf{Intermediate-set} = $\{m \mid m \in Locks, (indegree(m) = 0 \lor
  outdegree(m) = 0) \land \lnot (indegree(m) = 0 \land outdegree(m) = 0)\}$
  \item \textbf{Inner-set} = $\{m \mid m \in Locks, (\exists (t,m,L) \in D,
  \forall n \in L, n \in \text{Intermediate-set} \cup \text{Inner-set}) \lor
  (\exists (t,n,L) \in D, m \in L \land n \in \text{Intermediate-set} \cup
  \text{Inner-set})\}$
  \item \textbf{Cyclic-set} = $\{m \mid m \in Locks, m \notin
  \text{Independent-set} \cup \text{Intermediate-set} \cup \text{Inner-set}\}$
\end{enumerate}

Dazu werden die Algorithmen \textit{LockReduction(D)},
\textit{InitClassification(D)} und \textit{LockClassification(D)}
implementiert\footnote{Entspricht den Algorithmen 1, 2 und 3 aus
MagicLock\autocite[5]{MagicLock}}. Als erstes wird in
\cref{lst:LockReduction_InitClassification} mit \textit{InitClassification(D)}
eine Datenstruktur initialisiert.

\begin{listing}[ht]
  \inputminted[frame=lines,linenos,firstline=17,lastline=32]{python}{./Python/magiclockLib/lockReduction.py}
  \caption{magiclockLib/lockReduction.py: Implementierung des \textit{InitClassification(D)} Algorithmus aus Magiclock[5]\autocite{MagicLock}}
  \label{lst:LockReduction_InitClassification}
\end{listing}

Für jede \texttt{LockDependency} werden die eingehenden und ausgehenden Kanten
und der Mode bestimmt. Der Mode ist entweder der Name des Threads, welcher als
einziger Thread in der \texttt{LockDependencyRelation} Zugriffe auf das
Lockobjekt ausführt, oder -1. Die erstellte Datenstruktur ist in
\cref{lst:MagiclockTypes_InitClassification} dargestellt.

\begin{listing}[ht]
  \inputminted[frame=lines,linenos,firstline=3,lastline=8]{python}{./Python/magiclockLib/magiclockTypes.py}
  \caption{magiclockLib/magiclockTypes.py: Datenstruktur der \texttt{init\_Classification(D)} Methode}
  \label{lst:MagiclockTypes_InitClassification}
\end{listing}

Die Klassifizierung der Lockobjekte erfolgt in
\cref{lst:LockReduction_LockClassification}.

\begin{listing}[ht]
  \inputminted[frame=lines,linenos,firstline=35,lastline=77]{python}{./Python/magiclockLib/lockReduction.py}
  \caption{magiclockLib/lockReduction.py: Implementierung des \textit{LockClassification(D)} Algorithmus aus Magiclock[5]\autocite{MagicLock}}
  \label{lst:LockReduction_LockClassification}
\end{listing}

Alle Lockobjekte ohne eingehende und ausgehende Kanten werden in den Zeilen 39
und 40 in das \textbf{Independent-set} eingefügt. Diese Lockobjekte können
ignoriert werden, da ein potenzieller Deadlock mindestens eine ausgehende und
eine eingehende Kante besitzen muss. Lockobjekte ohne eingehende oder ohne
ausgehende Kanten werden in den Zeilen 42 bis 44 in das
\textbf{Intermediate-set} eingefügt. Zusätzlich werden diese auf den Stack
\texttt{s} gelegt. In den Zeilen 46 bis 69 wird die Klassifizierung für das
\textbf{Inner-set} durchgeführt. Das oberste Lockobjekt \texttt{m} vom Stack \texttt{s}
wird entfernt und überprüft. Dies wird wiederholt bis der Stack keine
Lockobjekte mehr enthält. Wenn das Lockobjekt \texttt{m} keine eingehenden
Kanten besitzt, werden alle anderen Lockobjekte mit eingehenden Kanten in den
Zeilen 49 bis 58 durchlaufen. Die eingehenden Kanten des Lockobjekts \texttt{n}
können dann um die Anzahl der Kanten von dem Lockobjekt \texttt{m} zu \texttt{n}
reduziert werden. Wenn das Lockobjekt \texttt{n} anschließend selbst keine
eingehenden Kanten mehr besitzt, wird es auf den Stack \texttt{s} gelegt und in
das \textbf{Intermediate-set} eingefügt. Anschließend werden in den Zeilen 57
und 58 die Kanten von dem Lockobjekt \texttt{m} zu \texttt{n} und alle
ausgehenden Kanten von \texttt{m} auf 0 gesetzt. Das Gleiche wird für
Lockobjekte ohne ausgehende Kanten in den Zeilen 59 bis 69 gemacht. Zuletzt
werden in den Zeilen 71 bis 75 alle Lockobjekte, welche in keiner der Mengen
vorhanden sind, in das \textbf{Cyclic-set} eingefügt.

Der Algorithmus zur Reduzierung der \texttt{LockDependencyRelation} ist in
\cref{lst:LockReduction_LockReduction} dargestellt.

\begin{listing}[ht]
  \inputminted[frame=lines,linenos,firstline=90]{python}{./Python/magiclockLib/lockReduction.py}
  \caption{magiclockLib/lockReduction.py: Implementierung des \textit{LockReduction(D)} Algorithmus aus Magiclock[5]\autocite{MagicLock}}
  \label{lst:LockReduction_LockReduction}
\end{listing}

Als erstes wird die Klassifizierung der Lockobjekte durchgeführt. Anschließend
wird in den Zeilen 93 bis 103 das \textbf{Cyclic-set} durchlaufen und alle
Lockobjekte mit einem Mode ungleich -1 aus diesem entfernt. Diese Lockobjekte
können nicht Teil eines potenziellen Deadlocks sein, da sie nur von einem
einzigen Thread verwendet werden. In der Zeile 105 wird eine neue
\texttt{LockDependencyRelation} erzeugt, welche nur Lockobjekte aus dem
\textbf{Cyclic-set} enthält. Wenn sich diese Relation nicht von der
ursprünglichen unterscheidet ist die Lock Reduzierung abgeschlossen. Ansonsten
wird in Zeile 107 die Lock Reduzierung rekursiv mit der eben erzeugten
\texttt{LockDependencyRelation} erneut aufgerufen.
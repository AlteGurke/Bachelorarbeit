\section{Trace Funktion}
\label{section:Implementierung:Trace Funktion}
Aus dem in \cref{fig:LockTrace_Design} vorgestellten UML-Diagramm werden drei
Klassen und eine Enumeration in C++ implementiert.
\texttt{Lock\-Trace\-Entry\-Type} wird als \texttt{enum} mit den Werten
\texttt{Lock} und \texttt{Unlock} implementiert. Die Klasse
\texttt{LockTraceEntry} wird als einfache Datenklasse mit Get-Methoden für jedes
Attribut implementiert. Die beiden Klassen \texttt{Log\-Trace\-Entry\-Formatter}
und \texttt{LogTracer} werden als Singleton implementiert. Die Implementierung
für die Berechnung des genauen Zeitpunkts ist in
\cref{lst:LockTraceEntryFormatter_FormatLogTraceEntry} dargestellt.

\begin{listing}[ht]
  \inputminted[frame=lines,linenos,firstline=31,lastline=33]{cpp}{./cpp/LockTraceEntryFormatter.cc}
  \caption{Auszug aus LockTraceEntryFormatter.cc: Berechnung des Zeitpunkts}
  \label{lst:LockTraceEntryFormatter_FormatLogTraceEntry}   
\end{listing}

Der \texttt{chrono::time\_point} wird in Mikrosekunden seit dem 01.01.1970
umgerechnet. Mikrosekunden wurden als Genauigkeit gewählt, weil Millisekunden
nicht hochauflösend genug sind, um die chronologische Verwendung von
Lockobjekten darzustellen. Eine höhere Auflösung als Mikrosekunden würde die
Darstellung hingegen zu unübersichtlich machen.

\begin{listing}[ht]
  \inputminted[frame=lines,linenos,firstline=11,lastline=54]{cpp}{./cpp/LockTracer.cc}
  \caption{LockTracer.cc: Auszug aus der Implementierung des LockTracers}
  \label{lst:LockTracer}
\end{listing}

In \cref{lst:LockTracer} ist ein Auszug aus der Implementierung der Klasse
\texttt{LockTracer} dargestellt. Die \texttt{GetInstance()} Methode stellt
sicher, dass nur eine Instanz der Klasse zur Laufzeit existiert TODO: Referenz
C++11. Im Konstruktor wird einmalig geprüft, ob die notwendigen
Umgebungsvariablen existieren und korrekte Werte aufweisen. Wenn alle Variablen
vorhanden und die Variable \texttt{Name\-Of\-Environment\-Variable\-Enabled} den
Wert \texttt{true} hat, wird die Trace-Funktionalität aktiviert. In der Methode
\texttt{Add(Lock\-Trace\-Entry\& entry)} wird zuerst geprüft, ob die
Trace-Funktionalität aktiviert ist. Ist dies nicht der Fall wird die Methode
sofort beendet, dadurch wird die Laufzeit der OpenPEARL Anwendung bei
deaktivierter Trace-Funktionalität nicht negativ beeinflusst\footnote{Der
einmalige Aufruf des Konstruktors, sowie der Aufruf der Add Methode und das
Prüfen eines booleschen Wertes werden hier ignoriert.}. Es wird sichergestellt,
dass beim Beenden der Anwendung alle noch vorhanden Logeinträge in die
Trace-Datei geschrieben werden. Dies erfolgt über den Destruktor der Klasse in
Zeile 48.

\section{Analyse Programm}
\label{section:Implementierung:Analyse Programm}
Die Implementierung für die Analyse und die chronologische Darstellung der
Verwendung von \textit{SEMA} Objekten wird in Python\footnote{Python Version
3.7.3.} durchgeführt. Im ersten Schritt wird die Trace-Datei aus
\cref{section:Erzeugung der Trace-Datei} ausgelesen. Die einzelnen Logeinträge
werden von der Klasse
\texttt{Lock\-Action} repräsentiert, welche in \cref{lst:TraceFileReader}
dargestellt ist.

\begin{listing}[ht]
  \inputminted[frame=lines,linenos,firstline=1,lastline=10]{python}{./Python/traceFileReader.py}
  \caption{traceFileReader.py: Auszug aus der Implementierung des Trace-Datei Parsers}
  \label{lst:TraceFileReader}
\end{listing}

Anschließend wird aus den ausgelesenen Logeinträgen ein Graph erstellt. Dazu
wird die Python-Bibliothek Matplotlib\footnote{Matplotlib Version 3.1.3.}
verwendet. In \cref{lst:GenerateTimeline_CreateGraphValues} ist die Erzeugung
des Graphen dargestellt.

\begin{listing}[ht]
  \inputminted[frame=lines,linenos,firstline=16,lastline=38]{python}{./Python/generateTimeline.py}
  \caption{generateTimeline.py: Auszug aus der Bestimmung der einzelnen Werte für den Graphen}
  \label{lst:GenerateTimeline_CreateGraphValues}
\end{listing}

In den Zeilen 23 bis 25 werden die Threads und Zeitstempel in Hashsets
gespeichert und anschließend in den Zeilen 27 und 28 sortiert. In den Zeilen 30
bis 38 werden die Werte für die einzelnen Logeinträge bestimmt. Um die Threads
auf der Ordinate abzubilden, wird in Zeile 36 der Index des jeweiligen Threads
im sortierten Hashset verwendet. Dadurch entspricht jeder ganzzahlige Wert auf
der Ordinate einem Thread. Falls es mehrere Einträge für eine Thread mit dem
gleichen Zeitstempel gibt, wird in den Zeilen 33 und 34 ein Offset berechnet und
in der Zeile 36 hinzugefügt, um eine Überlappung zu verhindern. Für den Wert auf
der Abszisse wird das Delta der Zeitstempel zwischen dem jeweiligen Logeintrag
und dem niedrigsten Zeitstempel in der Zeile 31 berechnet. In Zeile 37 wird die
Farbe des Logeintrags und in Zeile 38 die Beschriftung festgelegt. Aus den
einzelnen Werten wird in \cref{lst:GenerateTimeline_PlotGraph} der Graph mit
Matplotlib erstellt und kann dann mit dem Befehl \texttt{plt.show()} dargestellt
werden.

\begin{listing}[ht]
  \inputminted[frame=lines,linenos,firstline=42,lastline=44]{python}{./Python/generateTimeline.py}
  \caption{generateTimeline.py: Auszug aus der Erzeugung des Graphen}
  \label{lst:GenerateTimeline_PlotGraph}
\end{listing}

\section{Visualisierung von potenziellen Deadlocks}
\label{section:Implementierung:Visualisierung von potenziellen Deadlocks}
\begin{itemize}
  \item Vorstellung der Implementierung des Algorithmus zur Erkennung von
  potenziellen Deadlocks MagicLock klassifiziert dazu jedes Lock-Objekt in eine
  der folgenden Mengen:
  \begin{enumerate}
    \item \textbf{Independent-set} = $\{m \mid m \in Locks, indegree(m) = 0
    \land outdegree(m) = 0\}$
    \item \textbf{Intermediate-set} = $\{m \mid m \in Locks, (indegree(m) = 0
    \lor outdegree(m) = 0) \land \lnot (indegree(m) = 0 \land outdegree(m) =
    0)\}$
    \item \textbf{Inner-set} = $\{m \mid m \in Locks, (\exists (t,m,L) \in D,
    \forall n \in L, n \in \text{Intermediate-set} \cup \text{Inner-set}) \lor
    (\exists (t,n,L) \in D, m \in L \land n \in \text{Intermediate-set} \cup
    \text{Inner-set})\}$
    \item \textbf{Cyclic-set} = $\{m \mid m \in Locks, m \notin
    \text{Independent-set} \cup \text{Intermediate-set} \cup \text{Inner-set}\}$
  \end{enumerate}
  \item Grafiken/Screenshots mit Analyse Beispielen
\end{itemize}
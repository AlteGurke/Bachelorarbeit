Bei der parallelen Programmierung ist Nebenläufigkeit ein bewusst genutztes
Mittel. Die Ausführung von solchen Programmen ist nicht deterministisch. Dies
führt dazu, dass Zugriffe auf gemeinsam genutzte Ressourcen synchronisiert
werden müssen. Bei der Synchronisierung können zur Laufzeit Deadlocks auftreten.
Diese werden in \cref{section:Deadlockerkennung allgemein} beschrieben. Für
Entwickler stellen potenzielle Deadlocks ein großes Problem dar, da sie oft erst
zur Laufzeit auffallen. Während der Entwicklung kann ein Entwickler
Nebenläufigkeitsprobleme, die zu Deadlocks führen können, nur sehr schwer
erkennen. Gerade in komplexen Anwendungen, in denen viele parallele Aufgaben
ausgeführt werden, ist es für den Entwickler nicht mehr möglich, potenzielle
Deadlocks zu erkennen. Automatisierte Tests können das Erkennen solcher Probleme
zwar verbessern, durch die nicht deterministische Ausführung bleiben jedoch
viele Probleme unerkannt. Für die Echtzeit-Programmiersprache PEARL gibt es
derzeit keine Unterstützung für den Entwickler, um solche Probleme effektiv zu
erkennen. Um den Entwickler besser unterstützen zu können, soll in dieser Arbeit
ein Verfahren vorgestellt und für OpenPEARL implementiert werden, welches die
chronologische Abfolge von verwendeten Synchronisationsmitteln darstellen und
potenzielle Deadlocks erkennen kann. 

In \cref{section:Deadlockerkennung allgemein} wird das grundlegende Verfahren
zur Identifizierung von potenziellen Deadlocks vorgestellt. Es wird beschrieben
was ein Deadlock ist und wie dynamische Verfahren zur Erkennung von Deadlocks
funktionieren. In \cref{section:PEARL} wird die Echtzeit-Programmiersprache
PEARL beschrieben. Es wird gezeigt, welche Synchronisationsmittel in PEARL
existieren und wie diese benutzt werden. In \cref{section:OpenPEARL} wird das
OpenPEARL Projekt, der Aufbau der OPENPearl-Umgebung und das Zusammenspiel des
Compilers und der Laufzeitumgebung dargestellt. Anschließend wird in
\cref{section:MagicLock} ein Algorithmus zur Erkennung von potenziellen
Deadlocks vorgestellt. Anhand eines Quellcode-Beispiels in PEARL wird der
Algorithmus Schritt für Schritt durchlaufen und erläutert. 

Das Design zur Implementierung des Algorithmus wird in \cref{chapter:Design}
beschrieben. In \cref{section:Analysieren der Trace-Datei} wird der in OpenPEARL
umzusetzende Anteil definiert um die benötigten Informationen für den
Algorithmus in einer Trace-Datei zusammenzustellen. Zusätzlich werden die
Anforderungen bezüglich der Performanz festgelegt. In \cref{section:Analysieren
der Trace-Datei} und \cref{section:Erweiterung: Potenzielle Deadlocks} werden
die Designs der Programmme zur Visualisierung der chronologischen Belegung der
Synchronisationsmittel und der Erkennung von potenziellen Deadlocks definiert.

In \cref{section:Implementierung:Trace-Funktion} wird die Implementierung zur
Erstellung der Trace-Datei in OpenPEARL beschrieben. Anschließend werden die
Implementierungen der Programmme zur Analyse und Visualisierung der Trace-Datei
in \cref{section:Implementierung:Analyse-Programm} und
\cref{section:Implementierung:Visualisierung von potenziellen Deadlocks}
vorgestellt.

Die Validierung der in \cref{chapter:Implementierung} erstellten Programme und
Funktionen wird in \cref{chapter:Validierung} durchgeführt. Schwerpunkt sind
hier die definierten Performanz-Anforderungen.

Abschließend werden in \cref{chapter:Ausblick} offene Punkte und
Weiterentwicklungen beschrieben.
Bei der parallelen Programmierung ist Nebenläufigkeit ein bewusst genutztes
Mittel um die gleichzeitige Ausführung von mehreren Aufgaben zu realisieren. Die
Ausführung von nebenläufigen Programmen ist nicht deterministisch. Mehrere
parallele Aufgaben können bei jeder Ausführung eines solchen Programms in einer
anderen Reihenfolge abgearbeitet werden. Dies führt dazu, dass Zugriffe auf
gemeinsam genutzte Ressourcen synchronisiert werden müssen.

Bei der Synchronisierung können zur Laufzeit sogenannte Deadlocks (engl.
Verklemmungen) auftreten. Für Entwickler stellen Deadlocks ein großes Problem
dar, da sie oft erst zur Laufzeit auffallen. Während der Entwicklung kann ein
Entwickler Nebenläufigkeitsprobleme, die zu Deadlocks führen können, nur sehr
schwer erkennen. Gerade in komplexen Anwendungen, in denen viele parallele
Aufgaben ausgeführt werden, ist es für den Entwickler nicht mehr möglich,
potenzielle Deadlocks zu erkennen. Automatisierte Tests können das Erkennen
solcher Probleme zwar verbessern, durch die nicht deterministische Ausführung
bleiben jedoch viele Probleme unerkannt. Für die Echtzeit-Programmiersprache
PEARL gibt es derzeit keine Unterstützung für den Entwickler, um solche Probleme
effektiv zu erkennen. Um den Entwickler besser unterstützen zu können, soll in
dieser Arbeit ein Verfahren vorgestellt und implementiert werden, welches die
chronologische Abfolge von verwendeten Synchronisationsmitteln darstellen und
potenzielle Deadlocks erkennen kann. Das Ziel dieser Arbeit besteht darin
Entwicklern eine einfache Möglichkeit zu bieten potentielle Deadlocks in
PEARL-Programmen zu finden.

In \cref{section:Deadlockerkennung allgemein} wird das grundlegende Verfahren
zur Identifizierung von potenziellen Deadlocks vorgestellt. Es wird beschrieben,
was ein Deadlock ist und wie dynamische Verfahren zur Erkennung von Deadlocks
funktionieren. In \cref{section:PEARL} wird die Echtzeit-Programmiersprache
PEARL beschrieben. Es wird gezeigt, welche Synchronisationsmittel in PEARL
existieren und wie diese benutzt werden. Anschließend wird in
\cref{section:OpenPEARL} das OpenPEARL Projekt, der Aufbau der
OpenPearl-Umgebung und das Zusammenspiel des Compilers und der Laufzeitumgebung
dargestellt. In \cref{section:MagicLock} wird ein Algorithmus zur Erkennung von
potenziellen Deadlocks vorgestellt. Anhand eines Quellcode-Beispiels in PEARL
wird der Algorithmus Schritt für Schritt durchlaufen und erläutert. 

Das Design zur Implementierung des Algorithmus wird in \cref{chapter:Design}
beschrieben. In \cref{section:Analysieren der Trace-Datei} wird der in OpenPEARL
umzusetzende Anteil definiert um die benötigten Informationen für den
Algorithmus in einer Trace-Datei zusammenzustellen. In \cref{section:Analysieren
der Trace-Datei} und \cref{section:Erweiterung: Potenzielle Deadlocks} werden
die Designs der Programmme zur Visualisierung der chronologischen Belegung der
Synchronisationsmittel und der Erkennung von potenziellen Deadlocks definiert.

In \cref{section:Implementierung:Trace-Funktion} wird die Implementierung zur
Erstellung der Trace-Datei in OpenPEARL beschrieben. Anschließend werden die
Implementierungen der Programmme zur Analyse und Visualisierung der Trace-Datei
in \cref{section:Implementierung:Analyse-Programm} und
\cref{section:Implementierung:Visualisierung von potenziellen Deadlocks}
vorgestellt.

Die Validierung der in \cref{chapter:Implementierung} erstellten Programme und
Funktionen wird in \cref{chapter:Validierung} durchgeführt.

Abschließend werden in \cref{chapter:Ausblick} die Ergebnisse der Arbeit
zusammengefasst und offene Punkte und mögliche Weiterentwicklungen beschrieben.
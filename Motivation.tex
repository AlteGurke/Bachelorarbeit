Bei der parallelen Programmierung ist Nebenläufigkeit ein bewusst genutztes Mittel. Die Ausführung von solchen Programmen ist nicht deterministisch. Dies führt dazu, dass Zugriffe auf gemeinsam genutzte Ressourcen synchronisiert werden müssen. Bei der Synchronisierung können zur Laufzeit Deadlocks auftreten. Diese werden in \cref{section:Deadlockerkennung allgemein} beschrieben. Für Entwickler stellen potenzielle Deadlocks ein großes Problem dar, da sie oft erst zur Laufzeit auffallen. Während der Entwicklung kann ein Entwickler Nebenläufigkeitsprobleme die zu Deadlocks führen können nur sehr schwer erkennen. Gerade in komplexen Anwendungen in denen viele parallele Aufgaben ausgeführt werden, ist es für den Entwickler nicht mehr möglich potenzielle Deadlocks zu erkennen. Automatisierte Tests können das Erkennen solcher Probleme zwar verbessern, durch die nicht deterministische Ausführung bleiben jedoch viele Probleme unerkannt. Für die Echtzeit-Programmiersprache PEARL gibt es derzeit keine Unterstützung für den Entwickler um solche Probleme effektiv zu erkennen. Um den Entwickler besser unterstützen zu können wird ein Verfahren vorgestellt und für PEARL implementiert, welches die chronologische Abfolge von verwendeten Synchronisationsmitteln darstellen und potenzielle Deadlocks erkennen kann.

In \cref{section:Deadlockerkennung allgemein} wird das grundlegende Verfahren zur Identifizierung von potenziellen Deadlocks vorgestellt. Es wird dargestellt was ein Deadlock ist und wie dynamische Verfahren zur Erkennung von Deadlocks funktionieren. In \cref{section:PEARL} wird die Echtzeit-Programmiersprache PEARL \autocite{PEARL} beschrieben. Es wird gezeigt welche Synchronisationsmittel in PEARL existieren und wie diese benutzt werden. In \cref{section:OpenPEARL} wird das OpenPEARL Projekt und der Aufbau der OpenPEARL Umgebung sowie das Zusammenspiel des Compilers und der Laufzeitumgebung aufgezeigt. Anschließend wird ein Algorithmus zur Erkennung von potenziellen Deadlocks in \cref{section:MagicLock} beschrieben. Anhand eines Quellcode Beispiels in PEARL wird der Algorithmus Schritt für Schritt durchlaufen und erläutert. 

Das Design zur Implementierung des Algorithmus wird in \cref{chapter:Design} beschrieben. In \cref{section:Analysieren der Trace-Datei} wird der in PEARL umzusetzende Anteil definiert, um die benötigten Informationen für den Algorithmus in einer Trace-Datei zusammenzustellen. Zusätzlich werden die Anforderungen bezüglich der Performanz festgelegt. In \cref{section:Analysieren der Trace-Datei} wird das Design des Programms zur Visualisierung der chronologischen Belegung der Synchronisationsmittel basierend auf den Informationen der erstellten Trace-Datei definiert. In \cref{section:Erweiterung: Potenzielle Deadlocks} wird eine Erweiterung des Analyse-Programms vorgestellt. Zusätzlich zu der chronologischen Belegung der Synchronisationsmittel werden potenzielle Deadlocks erkannt. Es wird beschrieben wie die Visualisierung aussehen und wie der in \cref{section:MagicLock} vorgestellte Algorithmus umgesetzt werden soll.

In \cref{section:Implementierung:Trace Funktion} wird die Implementierung zur Erstellung der Trace-Datei in PEARL beschrieben. Anschließend werden die Implementierungen des Programms zur Analyse und Visualisierung der Trace-Datei in \cref{section:Implementierung:Analyse Programm} und \cref{section:Implementierung:Visualisierung von potenziellen Deadlocks} vorgestellt.

Die Validierung der in \cref{chapter:Implementierung} erstellten Programme und Funktionen wird in \cref{chapter:Validierung} beschrieben. Dabei werden vor allem die definierten Performanz Anforderungen validiert.

Abschließend werden in \cref{chapter:Ausblick} offene Punkte und mögliche Weiterentwicklung beschrieben.